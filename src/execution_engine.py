"""
Execution Engine Framework

A modular execution engine that orchestrates order execution, tracks state,
and provides comprehensive performance analytics.
"""

from __future__ import annotations

import uuid
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
from typing import List, Optional, Dict, Any, Type

import numpy as np
import pandas as pd

from .base_strategy import BaseStrategy, ExecutionMetrics, ExecutionSlice
from .order_book import OrderBook
from .market_data import calculate_vwap


# =============================================================================
# Enums and Constants
# =============================================================================

class OrderSide(Enum):
    """Order direction."""
    BUY = "buy"
    SELL = "sell"


class OrderStatus(Enum):
    """Order lifecycle status."""
    PENDING = "pending"
    ACTIVE = "active"
    PARTIALLY_FILLED = "partially_filled"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


class ChildOrderType(Enum):
    """Type of child order."""
    MARKET = "market"
    LIMIT = "limit"
    PEGGED = "pegged"


# =============================================================================
# Order Classes
# =============================================================================

@dataclass
class ParentOrder:
    """
    A parent order representing the full trading intention.
    
    This is the top-level order that gets broken down into child orders
    by the execution engine based on the selected strategy.
    
    Attributes:
        order_id: Unique identifier for this order
        symbol: Stock symbol (e.g., "AAPL")
        side: Buy or sell
        total_quantity: Total shares to execute
        time_horizon_minutes: Time available for execution
        start_time: When execution should begin
        strategy_name: Name of execution strategy to use
        urgency: 0.0 (patient) to 1.0 (aggressive)
        price_limit: Optional limit price constraint
    """
    symbol: str
    side: OrderSide
    total_quantity: int
    time_horizon_minutes: int
    start_time: Optional[datetime] = None
    strategy_name: str = "VWAP"
    urgency: float = 0.5
    price_limit: Optional[float] = None
    order_id: str = field(default_factory=lambda: str(uuid.uuid4())[:8])
    
    # State tracking (updated by engine)
    status: OrderStatus = OrderStatus.PENDING
    filled_quantity: int = 0
    average_price: float = 0.0
    created_at: datetime = field(default_factory=datetime.now)
    
    @property
    def remaining_quantity(self) -> int:
        """Shares still to be executed."""
        return self.total_quantity - self.filled_quantity
    
    @property
    def fill_rate(self) -> float:
        """Percentage of order filled."""
        if self.total_quantity == 0:
            return 0.0
        return self.filled_quantity / self.total_quantity
    
    @property
    def is_complete(self) -> bool:
        """Whether order is fully executed."""
        return self.filled_quantity >= self.total_quantity
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for reporting."""
        return {
            "order_id": self.order_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "total_quantity": self.total_quantity,
            "filled_quantity": self.filled_quantity,
            "remaining_quantity": self.remaining_quantity,
            "average_price": self.average_price,
            "fill_rate": f"{self.fill_rate * 100:.1f}%",
            "status": self.status.value,
            "strategy": self.strategy_name,
            "time_horizon": f"{self.time_horizon_minutes} min"
        }


@dataclass
class ChildOrder:
    """
    A child order generated by the execution engine.
    
    Represents a single slice of the parent order to be executed
    at a specific time.
    
    Attributes:
        parent_id: Reference to parent order
        child_id: Unique identifier for this child
        sequence: Order sequence number (1, 2, 3, ...)
        target_quantity: Shares to execute in this slice
        target_time: When this slice should execute
        order_type: Market, limit, or pegged
        limit_price: Price limit (if applicable)
    """
    parent_id: str
    target_quantity: int
    target_time: datetime
    sequence: int = 0
    order_type: ChildOrderType = ChildOrderType.MARKET
    limit_price: Optional[float] = None
    child_id: str = field(default_factory=lambda: str(uuid.uuid4())[:8])
    
    # Execution state
    status: OrderStatus = OrderStatus.PENDING
    filled_quantity: int = 0
    execution_price: float = 0.0
    executed_at: Optional[datetime] = None
    market_price_at_execution: float = 0.0
    spread_at_execution: float = 0.0
    market_impact: float = 0.0
    
    @property
    def slippage(self) -> float:
        """Price slippage from market mid price."""
        if self.execution_price > 0 and self.market_price_at_execution > 0:
            return self.execution_price - self.market_price_at_execution
        return 0.0
    
    @property
    def slippage_bps(self) -> float:
        """Slippage in basis points."""
        if self.market_price_at_execution > 0:
            return self.slippage / self.market_price_at_execution * 10000
        return 0.0
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for reporting."""
        return {
            "child_id": self.child_id,
            "parent_id": self.parent_id,
            "sequence": self.sequence,
            "target_qty": self.target_quantity,
            "filled_qty": self.filled_quantity,
            "exec_price": f"${self.execution_price:.4f}" if self.execution_price else "-",
            "market_price": f"${self.market_price_at_execution:.4f}" if self.market_price_at_execution else "-",
            "slippage_bps": f"{self.slippage_bps:+.2f}",
            "status": self.status.value
        }


# =============================================================================
# Execution State
# =============================================================================

@dataclass
class ExecutionState:
    """
    Tracks the current state of order execution.
    
    Provides real-time visibility into execution progress.
    """
    parent_order: ParentOrder
    child_orders: List[ChildOrder] = field(default_factory=list)
    current_minute: int = 0
    
    # Accumulated metrics
    total_value_executed: float = 0.0
    total_spread_cost: float = 0.0
    total_impact_cost: float = 0.0
    execution_prices: List[float] = field(default_factory=list)
    
    # Timestamps
    started_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None
    
    @property
    def elapsed_minutes(self) -> int:
        """Minutes since execution started."""
        return self.current_minute
    
    @property
    def average_execution_price(self) -> float:
        """Volume-weighted average execution price."""
        if self.parent_order.filled_quantity > 0:
            return self.total_value_executed / self.parent_order.filled_quantity
        return 0.0
    
    @property
    def total_cost(self) -> float:
        """Total execution cost (spread + impact)."""
        return self.total_spread_cost + self.total_impact_cost
    
    @property
    def timing_risk(self) -> float:
        """Standard deviation of execution prices."""
        if len(self.execution_prices) > 1:
            return float(np.std(self.execution_prices))
        return 0.0


# =============================================================================
# Execution Report
# =============================================================================

@dataclass  
class ExecutionReport:
    """
    Comprehensive report of execution performance.
    
    Generated after order completion with full analytics.
    """
    # Order info
    order_id: str
    symbol: str
    side: str
    total_quantity: int
    filled_quantity: int
    
    # Execution quality
    average_execution_price: float
    benchmark_vwap: float
    benchmark_twap: float
    arrival_price: float
    
    # Slippage analysis
    slippage_vs_vwap_bps: float
    slippage_vs_twap_bps: float
    slippage_vs_arrival_bps: float
    
    # Cost breakdown
    total_cost: float
    spread_cost: float
    impact_cost: float
    cost_per_share: float
    
    # Risk metrics
    timing_risk: float
    
    # Execution stats
    fill_rate: float
    num_child_orders: int
    execution_time_minutes: int
    strategy_used: str
    
    # Timestamps
    started_at: Optional[datetime]
    completed_at: Optional[datetime]
    
    def to_dataframe(self) -> pd.DataFrame:
        """Convert to DataFrame for display."""
        data = {
            "Metric": [
                "Order ID", "Symbol", "Side",
                "Total Quantity", "Filled Quantity", "Fill Rate",
                "Avg Execution Price", "Benchmark VWAP", "Arrival Price",
                "Slippage vs VWAP", "Slippage vs Arrival",
                "Total Cost", "Spread Cost", "Impact Cost", "Cost/Share",
                "Timing Risk",
                "Child Orders", "Execution Time", "Strategy"
            ],
            "Value": [
                self.order_id, self.symbol, self.side,
                f"{self.total_quantity:,}", f"{self.filled_quantity:,}", f"{self.fill_rate*100:.1f}%",
                f"${self.average_execution_price:.4f}", f"${self.benchmark_vwap:.4f}", f"${self.arrival_price:.4f}",
                f"{self.slippage_vs_vwap_bps:+.2f} bps", f"{self.slippage_vs_arrival_bps:+.2f} bps",
                f"${self.total_cost:.2f}", f"${self.spread_cost:.2f}", f"${self.impact_cost:.2f}", f"${self.cost_per_share:.4f}",
                f"${self.timing_risk:.4f}",
                str(self.num_child_orders), f"{self.execution_time_minutes} min", self.strategy_used
            ]
        }
        return pd.DataFrame(data)
    
    def __repr__(self) -> str:
        return (
            f"ExecutionReport(order={self.order_id})\n"
            f"  {self.side.upper()} {self.filled_quantity:,}/{self.total_quantity:,} {self.symbol}\n"
            f"  Avg Price: ${self.average_execution_price:.4f} | VWAP: ${self.benchmark_vwap:.4f}\n"
            f"  Slippage: {self.slippage_vs_vwap_bps:+.2f} bps | Cost: ${self.total_cost:.2f}\n"
            f"  Strategy: {self.strategy_used} | Time: {self.execution_time_minutes} min"
        )


# =============================================================================
# Execution Engine
# =============================================================================

class ExecutionEngine:
    """
    Modular execution engine for algorithmic order execution.
    
    Orchestrates the full lifecycle of order execution:
    1. Accepts parent orders
    2. Generates child orders based on strategy
    3. Simulates execution with realistic market dynamics
    4. Tracks state and calculates performance metrics
    
    Example:
        >>> engine = ExecutionEngine()
        >>> order = ParentOrder(symbol="AAPL", side=OrderSide.BUY, 
        ...                     total_quantity=10000, time_horizon_minutes=60)
        >>> report = engine.process_order(order, market_data, VWAPStrategy())
        >>> print(report)
    """
    
    def __init__(
        self,
        order_book: Optional[OrderBook] = None,
        seed: Optional[int] = None
    ):
        """
        Initialize the execution engine.
        
        Args:
            order_book: OrderBook for execution simulation
            seed: Random seed for reproducibility
        """
        self.order_book = order_book or OrderBook(seed=seed)
        self.rng = np.random.default_rng(seed)
        
        # Current execution state
        self.state: Optional[ExecutionState] = None
        
        # History
        self.execution_history: List[ExecutionReport] = []
    
    def process_order(
        self,
        parent_order: ParentOrder,
        market_data: pd.DataFrame,
        strategy: BaseStrategy,
        start_minute: int = 0,
        end_minute: Optional[int] = None
    ) -> ExecutionReport:
        """
        Process a parent order through complete execution.
        
        This is the main entry point for order execution.
        
        Args:
            parent_order: The order to execute
            market_data: Market data for simulation
            strategy: Execution strategy to use
            start_minute: Minute index to start execution
            end_minute: Minute index to end execution
            
        Returns:
            ExecutionReport with complete performance analytics
        """
        # Validate inputs
        if parent_order.total_quantity <= 0:
            raise ValueError("Order quantity must be positive")
        
        if end_minute is None:
            end_minute = min(start_minute + parent_order.time_horizon_minutes, len(market_data))
        
        # Initialize state
        parent_order.status = OrderStatus.ACTIVE
        parent_order.start_time = market_data.iloc[start_minute]["timestamp"]
        
        self.state = ExecutionState(
            parent_order=parent_order,
            started_at=parent_order.start_time
        )
        
        # Extract execution window
        execution_data = market_data.iloc[start_minute:end_minute].copy()
        execution_data = execution_data.reset_index(drop=True)
        
        # Record arrival price (first price in window)
        arrival_price = execution_data.iloc[0]["price"]
        
        # Calculate execution schedule from strategy
        schedule = strategy.calculate_schedule(
            parent_order.total_quantity,
            execution_data
        )
        
        # Generate child orders
        child_orders = self._generate_child_orders(
            parent_order, 
            schedule, 
            execution_data
        )
        self.state.child_orders = child_orders
        
        # Execute each child order
        for child in child_orders:
            if child.target_quantity > 0:
                self._execute_slice(child, parent_order.side.value, execution_data)
        
        # Mark completion
        parent_order.status = (
            OrderStatus.FILLED if parent_order.is_complete 
            else OrderStatus.PARTIALLY_FILLED
        )
        self.state.completed_at = datetime.now()
        
        # Calculate final metrics
        report = self._calculate_metrics(execution_data, arrival_price, strategy.strategy_name)
        
        # Store in history
        self.execution_history.append(report)
        
        return report
    
    def _generate_child_orders(
        self,
        parent: ParentOrder,
        schedule: np.ndarray,
        market_data: pd.DataFrame
    ) -> List[ChildOrder]:
        """
        Generate child orders from execution schedule.
        
        Args:
            parent: Parent order
            schedule: Array of target quantities per minute
            market_data: Market data with timestamps
            
        Returns:
            List of ChildOrder objects
        """
        children = []
        sequence = 0
        
        for minute_idx, target_qty in enumerate(schedule):
            if target_qty > 0:
                sequence += 1
                child = ChildOrder(
                    parent_id=parent.order_id,
                    target_quantity=int(target_qty),
                    target_time=market_data.iloc[minute_idx]["timestamp"],
                    sequence=sequence,
                    order_type=ChildOrderType.MARKET
                )
                children.append(child)
        
        return children
    
    def _execute_slice(
        self,
        child: ChildOrder,
        side: str,
        market_data: pd.DataFrame
    ) -> None:
        """
        Execute a single child order slice.
        
        Updates the child order and parent order state.
        
        Args:
            child: Child order to execute
            side: 'buy' or 'sell'
            market_data: Market data
        """
        if self.state is None:
            raise RuntimeError("No active execution state")
        
        parent = self.state.parent_order
        
        # Find the market data row for this child's target time
        minute_idx = child.sequence - 1  # Assuming sequential
        if minute_idx >= len(market_data):
            child.status = OrderStatus.REJECTED
            return
        
        row = market_data.iloc[minute_idx]
        
        child.status = OrderStatus.ACTIVE
        child.market_price_at_execution = row["price"]
        child.spread_at_execution = row["spread"]
        
        # Generate order book snapshot
        snapshot = self.order_book.generate_snapshot(
            mid_price=row["price"],
            spread=row["spread"],
            minute_volume=row["volume"]
        )
        
        # Simulate execution
        avg_price, filled, impact = self.order_book.simulate_execution(
            snapshot=snapshot,
            order_size=child.target_quantity,
            side=side
        )
        
        # Update child order
        child.filled_quantity = filled
        child.execution_price = avg_price
        child.market_impact = impact
        child.executed_at = row["timestamp"]
        child.status = (
            OrderStatus.FILLED if filled >= child.target_quantity 
            else OrderStatus.PARTIALLY_FILLED
        )
        
        # Update parent order
        parent.filled_quantity += filled
        
        if filled > 0:
            # Update average price (incremental weighted average)
            total_value = parent.average_price * (parent.filled_quantity - filled) + avg_price * filled
            parent.average_price = total_value / parent.filled_quantity
            
            # Update state
            self.state.total_value_executed += avg_price * filled
            self.state.execution_prices.extend([avg_price] * filled)
            
            # Calculate costs
            if side == "buy":
                spread_cost = (snapshot.best_ask - row["price"]) * filled
            else:
                spread_cost = (row["price"] - snapshot.best_bid) * filled
            
            self.state.total_spread_cost += spread_cost
            self.state.total_impact_cost += abs(impact) * filled
        
        self.state.current_minute = minute_idx + 1
    
    def _calculate_metrics(
        self,
        market_data: pd.DataFrame,
        arrival_price: float,
        strategy_name: str
    ) -> ExecutionReport:
        """
        Calculate comprehensive execution metrics.
        
        Args:
            market_data: Market data used for execution
            arrival_price: Price at start of execution
            strategy_name: Name of strategy used
            
        Returns:
            ExecutionReport with all metrics
        """
        if self.state is None:
            raise RuntimeError("No active execution state")
        
        parent = self.state.parent_order
        
        # Calculate benchmarks
        benchmark_vwap = calculate_vwap(market_data)
        benchmark_twap = market_data["price"].mean()
        
        avg_price = self.state.average_execution_price
        
        # Calculate slippage (positive = worse for buyer)
        is_buy = parent.side == OrderSide.BUY
        
        if is_buy:
            slippage_vs_vwap = (avg_price - benchmark_vwap) / benchmark_vwap * 10000
            slippage_vs_twap = (avg_price - benchmark_twap) / benchmark_twap * 10000
            slippage_vs_arrival = (avg_price - arrival_price) / arrival_price * 10000
        else:
            slippage_vs_vwap = (benchmark_vwap - avg_price) / benchmark_vwap * 10000
            slippage_vs_twap = (benchmark_twap - avg_price) / benchmark_twap * 10000
            slippage_vs_arrival = (arrival_price - avg_price) / arrival_price * 10000
        
        # Count child orders
        num_children = len([c for c in self.state.child_orders if c.filled_quantity > 0])
        
        # Calculate cost per share
        cost_per_share = (
            self.state.total_cost / parent.filled_quantity 
            if parent.filled_quantity > 0 else 0.0
        )
        
        return ExecutionReport(
            order_id=parent.order_id,
            symbol=parent.symbol,
            side=parent.side.value,
            total_quantity=parent.total_quantity,
            filled_quantity=parent.filled_quantity,
            average_execution_price=avg_price,
            benchmark_vwap=benchmark_vwap,
            benchmark_twap=benchmark_twap,
            arrival_price=arrival_price,
            slippage_vs_vwap_bps=slippage_vs_vwap,
            slippage_vs_twap_bps=slippage_vs_twap,
            slippage_vs_arrival_bps=slippage_vs_arrival,
            total_cost=self.state.total_cost,
            spread_cost=self.state.total_spread_cost,
            impact_cost=self.state.total_impact_cost,
            cost_per_share=cost_per_share,
            timing_risk=self.state.timing_risk,
            fill_rate=parent.fill_rate,
            num_child_orders=num_children,
            execution_time_minutes=self.state.elapsed_minutes,
            strategy_used=strategy_name,
            started_at=self.state.started_at,
            completed_at=self.state.completed_at
        )
    
    def get_execution_report(self) -> Optional[ExecutionReport]:
        """
        Get the most recent execution report.
        
        Returns:
            Most recent ExecutionReport or None
        """
        if self.execution_history:
            return self.execution_history[-1]
        return None
    
    def get_child_orders_df(self) -> pd.DataFrame:
        """
        Get child orders as DataFrame.
        
        Returns:
            DataFrame with all child order details
        """
        if self.state is None or not self.state.child_orders:
            return pd.DataFrame()
        
        return pd.DataFrame([c.to_dict() for c in self.state.child_orders])
    
    def get_execution_history(self) -> pd.DataFrame:
        """
        Get history of all executions as DataFrame.
        
        Returns:
            DataFrame with summary of all past executions
        """
        if not self.execution_history:
            return pd.DataFrame()
        
        data = []
        for report in self.execution_history:
            data.append({
                "order_id": report.order_id,
                "symbol": report.symbol,
                "side": report.side,
                "quantity": report.filled_quantity,
                "avg_price": f"${report.average_execution_price:.2f}",
                "slippage_bps": f"{report.slippage_vs_vwap_bps:+.2f}",
                "cost": f"${report.total_cost:.2f}",
                "strategy": report.strategy_used
            })
        
        return pd.DataFrame(data)
